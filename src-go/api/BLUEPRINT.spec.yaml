# API Implementation Spec (Go)

_meta:
  version: "0.1.0"
  type: spec

implementation:
  structure:
    - exports.go
    - server.go
    - handlers.go

  library:
    description: |
      Public API re-exports via type aliases (Go).

    pseudocode: |
      package api

      type Agent = agent.Agent
      type AgentConfig = agent.AgentConfig
      type AgentResult = agent.AgentResult

      type ToolRegistry = tools.ToolRegistry
      type ToolSchema = tools.ToolSchema
      type ToolResult = tools.ToolResult

      type TaskStore = task.TaskStore
      type Task = task.Task
      type TaskStatus = task.TaskStatus

      type LLMRouter = llm.LLMRouter
      type ProviderAdapter = llm.ProviderAdapter
      type CompletionRequest = llm.CompletionRequest
      type LLMResponse = llm.LLMResponse
      type Message = llm.Message

  server:
    pseudocode: |
      package api

      type AgentServer struct {
          Port  int
          Agent *agent.Agent
          mux   *http.ServeMux
      }

      func NewAgentServer(port int, agentInstance *agent.Agent) *AgentServer {
          if agentInstance == nil {
              agentInstance = agent.New("api-agent", agent.AgentConfig{EnableTaskStore: true})
          }
          return &AgentServer{Port: port, Agent: agentInstance, mux: http.NewServeMux()}
      }

      func (s *AgentServer) Start() error {
          s.routes()
          addr := fmt.Sprintf(":%d", s.Port)
          return http.ListenAndServe(addr, s.mux)
      }

      func (s *AgentServer) routes() {
          s.mux.HandleFunc("/health", s.handleHealth)
          s.mux.HandleFunc("/tasks", s.handleTasks)
          s.mux.HandleFunc("/execute", s.handleExecute)
      }

  handlers:
    pseudocode: |
      func (s *AgentServer) handleHealth(w http.ResponseWriter, r *http.Request) {
          writeJSON(w, http.StatusOK, map[string]any{"status": "ok", "version": Version})
      }

      func (s *AgentServer) handleTasks(w http.ResponseWriter, r *http.Request) {
          limit := parseInt(r.URL.Query().Get("limit"), 10)
          tasks := s.Agent.Tasks.List(limit)
          writeJSON(w, http.StatusOK, map[string]any{"tasks": tasks})
      }

      func (s *AgentServer) handleExecute(w http.ResponseWriter, r *http.Request) {
          req := parseExecuteRequest(r)
          result := s.Agent.Execute(req.Instruction)
          writeJSON(w, http.StatusOK, result)
      }
