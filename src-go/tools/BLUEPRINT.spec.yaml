# Tools Implementation Spec (Go)

_meta:
  version: "0.1.0"
  type: spec

implementation:
  structure:
    - types.go
    - registry.go

  types:
    pseudocode: |
      package tools

      type ToolSchema struct {
          Name        string
          Description string
          Parameters  map[string]any
      }

      type ToolResult struct {
          Success bool
          Output  string
          Error   string
      }

      type ToolHandler func(args map[string]any) (string, error)

      type ToolEntry struct {
          Name    string
          Handler ToolHandler
          Schema  ToolSchema
      }

  registry:
    pseudocode: |
      package tools

      type ToolRegistry struct {
          mu    sync.RWMutex
          tools map[string]ToolEntry
      }

      func NewToolRegistry() *ToolRegistry {
          return &ToolRegistry{tools: map[string]ToolEntry{}}
      }

      func (r *ToolRegistry) Register(name string, handler ToolHandler, schema ToolSchema) error {
          r.mu.Lock()
          defer r.mu.Unlock()
          if name == "" || handler == nil {
              return fmt.Errorf("invalid tool")
          }
          if schema.Name == "" {
              schema.Name = name
          }
          if schema.Name != name {
              return fmt.Errorf("schema name mismatch")
          }
          if _, ok := r.tools[name]; ok {
              return fmt.Errorf("tool already registered")
          }
          r.tools[name] = ToolEntry{Name: name, Handler: handler, Schema: schema}
          return nil
      }

      func (r *ToolRegistry) Execute(name string, args map[string]any) ToolResult {
          r.mu.RLock()
          entry, ok := r.tools[name]
          r.mu.RUnlock()
          if !ok {
              return ToolResult{Success: false, Error: "tool not found"}
          }
          out, err := entry.Handler(args)
          if err != nil {
              return ToolResult{Success: false, Error: err.Error()}
          }
          return ToolResult{Success: true, Output: out}
      }

      func (r *ToolRegistry) GetSchemas() []ToolSchema {
          r.mu.RLock()
          defer r.mu.RUnlock()
          schemas := make([]ToolSchema, 0, len(r.tools))
          for _, entry := range r.tools {
              schemas = append(schemas, entry.Schema)
          }
          return schemas
      }

      func (r *ToolRegistry) Has(name string) bool {
          r.mu.RLock()
          defer r.mu.RUnlock()
          _, ok := r.tools[name]
          return ok
      }

      func (r *ToolRegistry) Count() int {
          r.mu.RLock()
          defer r.mu.RUnlock()
          return len(r.tools)
      }
