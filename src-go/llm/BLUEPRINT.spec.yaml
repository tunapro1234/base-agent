# LLM Client Implementation Spec (Go)

_meta:
  version: "0.4.0"
  type: spec

implementation:
  structure:
    - types.go
    - router.go
    - rotation.go
    - gemini_adapter.go
    - codex_adapter.go
    - opus_adapter.go

  types:
    pseudocode: |
      package llm

      type Message struct {
          Role    string
          Content string
      }

      type ToolCall struct {
          Name string
          Args map[string]any
      }

      type LLMResponse struct {
          Content   string
          ToolCalls []ToolCall
          Raw       map[string]any
      }

      type CompletionRequest struct {
          Messages        []Message
          Tools           []tools.ToolSchema
          Temperature     *float64
          Model           string
          Provider        string
          ReasoningEffort string
      }

      type ProviderAdapter interface {
          Complete(ctx context.Context, req CompletionRequest) (LLMResponse, error)
      }

  router:
    pseudocode: |
      package llm

      type LLMRouter struct {
          defaultProvider string
          providers       map[string]ProviderAdapter
      }

      func NewRouter(defaultProvider string) *LLMRouter {
          return &LLMRouter{
              defaultProvider: defaultProvider,
              providers:       map[string]ProviderAdapter{},
          }
      }

      func (r *LLMRouter) RegisterProvider(name string, adapter ProviderAdapter) {
          r.providers[name] = adapter
      }

      func (r *LLMRouter) Complete(ctx context.Context, req CompletionRequest) (LLMResponse, error) {
          provider := req.Provider
          if provider == "" {
              provider = r.defaultProvider
          }
          adapter, ok := r.providers[provider]
          if !ok {
              return LLMResponse{}, fmt.Errorf("provider not registered: %s", provider)
          }
          return adapter.Complete(ctx, req)
      }

  rotation:
    pseudocode: |
      package llm

      type Rotator struct {
          mu   sync.Mutex
          keys []string
          next int
      }

      func NewRotator(keys []string) *Rotator {
          return &Rotator{keys: keys}
      }

      func (r *Rotator) Next() string {
          r.mu.Lock()
          defer r.mu.Unlock()
          if len(r.keys) == 0 {
              return ""
          }
          key := r.keys[r.next%len(r.keys)]
          r.next++
          return key
      }

  gemini:
    pseudocode: |
      package llm

      type GeminiConfig struct {
          APIKeys     []string
          Model       string
          Temperature float64
      }

      type GeminiAdapter struct {
          cfg     GeminiConfig
          rotator *Rotator
      }

      func NewGeminiAdapter(cfg GeminiConfig) *GeminiAdapter {
          return &GeminiAdapter{cfg: cfg, rotator: NewRotator(cfg.APIKeys)}
      }

      func (a *GeminiAdapter) Complete(ctx context.Context, req CompletionRequest) (LLMResponse, error) {
          // HTTP call to Gemini API or SDK
          return LLMResponse{}, nil
      }

  codex:
    pseudocode: |
      package llm

      type CodexConfig struct {
          APIKeys         []string
          AuthFiles       []string
          Model           string
          ReasoningEffort string
      }

      type CodexAdapter struct {
          cfg     CodexConfig
          rotator *Rotator
      }

      func NewCodexAdapter(cfg CodexConfig) *CodexAdapter {
          return &CodexAdapter{cfg: cfg, rotator: NewRotator(cfg.APIKeys)}
      }

      func (a *CodexAdapter) Complete(ctx context.Context, req CompletionRequest) (LLMResponse, error) {
          // HTTP call to Codex API
          return LLMResponse{}, nil
      }

  opus:
    pseudocode: |
      package llm

      type OpusConfig struct {
          APIKeys     []string
          BaseURL     string
          Endpoint    string
          Model       string
          Temperature float64
      }

      type OpusAdapter struct {
          cfg     OpusConfig
          rotator *Rotator
      }

      func NewOpusAdapter(cfg OpusConfig) *OpusAdapter {
          return &OpusAdapter{cfg: cfg, rotator: NewRotator(cfg.APIKeys)}
      }

      func (a *OpusAdapter) Complete(ctx context.Context, req CompletionRequest) (LLMResponse, error) {
          // HTTP call to Opus-compatible endpoint
          return LLMResponse{}, nil
      }
