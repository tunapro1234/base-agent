# Task Implementation Spec

_meta:
  version: "0.1.0"
  type: spec

implementation:
  store:
    pseudocode: |
      class TaskStore:
        def __init__(self, persist: bool = False, path: str = None):
          self.persist = persist
          self.path = path or "tasks.json"
          self._tasks: dict[str, Task] = {}

          # Load existing tasks if persist enabled
          if self.persist:
            self._load()

        def create(self, instruction: str) -> Task:
          task = Task(
            id=generate_task_id(),
            instruction=instruction,
            status=TaskStatus.PENDING,
            created_at=datetime.now().isoformat()
          )

          self._tasks[task.id] = task
          self._save_if_persist()

          return task

        def update(self, id: str, status: str = None, output: str = None, error: str = None) -> Task:
          if id not in self._tasks:
            raise TaskNotFoundError(f"Task {id} not found")

          task = self._tasks[id]

          if status:
            task.status = TaskStatus(status)

          if output is not None:
            task.output = output

          if error is not None:
            task.error = error

          if status in ["completed", "failed"]:
            task.completed_at = datetime.now().isoformat()

          self._save_if_persist()
          return task

        def get(self, id: str) -> Task | None:
          return self._tasks.get(id)

        def list(self, limit: int = 10) -> list[Task]:
          tasks = sorted(
            self._tasks.values(),
            key=lambda t: t.created_at,
            reverse=True
          )
          return tasks[:limit]

        def _save_if_persist(self):
          if not self.persist:
            return

          data = [t.to_dict() for t in self._tasks.values()]
          with open(self.path, "w") as f:
            json.dump(data, f, indent=2)

        def _load(self):
          if not os.path.exists(self.path):
            return

          with open(self.path, "r") as f:
            data = json.load(f)

          for item in data:
            task = Task.from_dict(item)
            self._tasks[task.id] = task

  types:
    pseudocode: |
      class TaskStatus(Enum):
        PENDING = "pending"
        RUNNING = "running"
        COMPLETED = "completed"
        FAILED = "failed"

      @dataclass
      class Task:
        id: str
        instruction: str
        status: TaskStatus
        created_at: str
        output: str = None
        error: str = None
        completed_at: str = None

        def to_dict(self) -> dict:
          return {
            "id": self.id,
            "instruction": self.instruction,
            "status": self.status.value,
            "output": self.output,
            "error": self.error,
            "created_at": self.created_at,
            "completed_at": self.completed_at
          }

        @classmethod
        def from_dict(cls, data: dict) -> "Task":
          return cls(
            id=data["id"],
            instruction=data["instruction"],
            status=TaskStatus(data["status"]),
            output=data.get("output"),
            error=data.get("error"),
            created_at=data["created_at"],
            completed_at=data.get("completed_at")
          )

      class TaskNotFoundError(Exception):
        pass

  helpers:
    id_generation:
      pseudocode: |
        import random
        import string
        from datetime import datetime

        def generate_task_id() -> str:
          """Generate unique task ID: YYYYMMDD_HHMMSS_XXXX"""
          timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
          suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=4))
          return f"{timestamp}_{suffix}"

        # Example: "20260117_143052_a1b2"

tests:
  unit:
    - name: create_task
      test: |
        store = TaskStore()
        task = store.create("Test instruction")

        assert task.id is not None
        assert task.instruction == "Test instruction"
        assert task.status == TaskStatus.PENDING
        assert task.created_at is not None

    - name: update_task
      test: |
        store = TaskStore()
        task = store.create("Test")

        updated = store.update(task.id, status="completed", output="Done")

        assert updated.status == TaskStatus.COMPLETED
        assert updated.output == "Done"
        assert updated.completed_at is not None

    - name: get_task
      test: |
        store = TaskStore()
        task = store.create("Test")

        retrieved = store.get(task.id)
        assert retrieved.id == task.id

        not_found = store.get("nonexistent")
        assert not_found is None

    - name: list_tasks
      test: |
        store = TaskStore()
        store.create("Task 1")
        store.create("Task 2")
        store.create("Task 3")

        tasks = store.list(limit=2)
        assert len(tasks) == 2

    - name: persistence
      test: |
        # Create and persist
        store1 = TaskStore(persist=True, path="/tmp/test_tasks.json")
        task = store1.create("Persist test")
        store1.update(task.id, status="completed", output="Done")

        # Load in new instance
        store2 = TaskStore(persist=True, path="/tmp/test_tasks.json")
        loaded = store2.get(task.id)

        assert loaded is not None
        assert loaded.instruction == "Persist test"
        assert loaded.status == TaskStatus.COMPLETED

    - name: id_uniqueness
      test: |
        ids = [generate_task_id() for _ in range(100)]
        assert len(ids) == len(set(ids))  # All unique
