# API Implementation Spec

_meta:
  version: "0.1.0"
  type: spec

implementation:
  library:
    description: |
      Public exports for direct import.
      Tek bir entry point uzerinden tum public API'yi expose et.

    pseudocode: |
      # __init__.py veya index.ts

      from .agent import Agent, AgentConfig, AgentResult
      from .tools import ToolRegistry, ToolSchema, ToolResult
      from .task import TaskStore, Task, TaskStatus
      from .llm import (
        LLMRouter, ProviderAdapter, CompletionRequest,
        LLMResponse, ProviderError, Message,
        GeminiAdapter, GeminiConfig,
        CodexAdapter, CodexConfig, CodexAuth,
        OpusAdapter, OpusConfig
      )

      __all__ = [
        "Agent",
        "AgentConfig",
        "AgentResult",
        "ToolRegistry",
        "ToolSchema",
        "ToolResult",
        "TaskStore",
        "Task",
        "TaskStatus",
        "LLMRouter",
        "ProviderAdapter",
        "CompletionRequest",
        "LLMResponse",
        "ProviderError",
        "Message",
        "GeminiAdapter",
        "GeminiConfig",
        "CodexAdapter",
        "CodexConfig",
        "CodexAuth",
        "OpusAdapter",
        "OpusConfig",
      ]

      # Usage:
      # from base_agent import Agent, ToolSchema
      # agent = Agent("my-agent")
      # result = agent.execute("Do something")

  http_server:
    description: REST API server

    pseudocode: |
      # Minimal HTTP server (framework-agnostic pseudocode)

      class AgentServer:
        def __init__(self, port: int = 8080):
          self.port = port
          self.agent = Agent("api-agent")
          # /tasks endpoint requires task store
          if not self.agent.tasks:
            raise RuntimeError("TaskStore disabled. Enable task store for /tasks endpoint.")

        def start(self):
          server = create_http_server(self.port)
          server.route("POST", "/execute", self.handle_execute)
          server.route("GET", "/tasks", self.handle_tasks)
          server.route("GET", "/tasks/{id}", self.handle_task_detail)
          server.route("GET", "/tools", self.handle_tools)
          server.route("GET", "/models", self.handle_models)
          server.route("GET", "/health", self.handle_health)
          server.listen()

        def handle_execute(self, request) -> Response:
          body = request.json()

          # Validate
          if not body.get("instruction"):
            return Response(400, {"error": "instruction required"})

          # Configure agent if custom prompt
          if body.get("system_prompt"):
            self.agent.system_prompt = body["system_prompt"]

          provider = body.get("provider")
          model = body.get("model")
          temperature = body.get("temperature")
          debug = bool(body.get("debug"))

          # Register tools if provided
          if body.get("tools"):
            for tool_def in body["tools"]:
              # Tools are registered but handlers must be pre-defined
              pass

          # Execute
          try:
            # Optional: override provider/model/temperature for this run
            result = self.agent.execute(body["instruction"])
            payload = {
              "success": result.success,
              "output": result.output,
              "task_id": result.task_id
            }
            if debug and getattr(result, "trace", None):
              payload["trace"] = result.trace
            return Response(200, payload)
          except Exception as e:
            return Response(500, {"error": str(e)})

        def handle_tasks(self, request) -> Response:
          limit = request.query.get("limit", 10)
          if not self.agent.tasks:
            return Response(503, {"error": "task store disabled"})
          tasks = self.agent.tasks.list(limit=int(limit))
          return Response(200, {
            "tasks": [t.to_dict() for t in tasks]
          })

        def handle_task_detail(self, request) -> Response:
          task_id = request.path_params["id"]
          if not self.agent.tasks:
            return Response(503, {"error": "task store disabled"})
          task = self.agent.tasks.get(task_id)
          if not task:
            return Response(404, {"error": "task not found"})
          return Response(200, task.to_dict())

        def handle_tools(self, request) -> Response:
          tools = []
          for schema in self.agent.tools.get_schemas():
            tools.append({
              "name": schema.name,
              "description": schema.description
            })
          return Response(200, {"tools": tools})

        def handle_models(self, request) -> Response:
          provider = self.agent.config.provider
          models = []
          if provider == "gemini":
            models = GEMINI_ALLOWED_MODELS
          elif provider == "codex":
            models = CODEX_MODELS
          elif provider == "opus":
            models = [self.agent.config.model]
          return Response(200, {"models": models})

        def handle_health(self, request) -> Response:
          return Response(200, {
            "status": "ok",
            "version": "0.1.0"
          })

      # Entry point
      if __name__ == "__main__":
        port = int(os.getenv("PORT", 8080))
        server = AgentServer(port)
        print(f"Starting server on port {port}")
        server.start()

  docker:
    dockerfile: |
      # Base image - adjust for your language
      FROM python:3.12-slim
      # FROM node:20-slim
      # FROM golang:1.22-alpine

      WORKDIR /app

      # Copy source
      COPY src/ ./src/
      COPY requirements.txt ./
      # COPY package.json ./
      # COPY go.mod go.sum ./

      # Install dependencies
      RUN pip install --no-cache-dir -r requirements.txt
      # RUN npm install --production
      # RUN go mod download

      # Expose port
      EXPOSE 8080

      # Health check
      HEALTHCHECK --interval=30s --timeout=3s \
        CMD curl -f http://localhost:8080/health || exit 1

      # Run server
      CMD ["python", "src/api/server.py"]
      # CMD ["node", "src/api/server.js"]
      # CMD ["./server"]

    docker_compose: |
      version: "3.8"

      services:
        base-agent:
          build: .
          ports:
            - "${PORT:-8080}:8080"
          environment:
            - GEMINI_API_KEY=${GEMINI_API_KEY}
            - GEMINI_API_KEY_2=${GEMINI_API_KEY_2:-}
            - GEMINI_API_KEY_3=${GEMINI_API_KEY_3:-}
            - GEMINI_API_KEY_4=${GEMINI_API_KEY_4:-}
            - GEMINI_API_KEY_5=${GEMINI_API_KEY_5:-}
            - PORT=8080
          restart: unless-stopped
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
            interval: 30s
            timeout: 3s
            retries: 3

    usage: |
      # Build
      docker build -t base-agent .

      # Run (with .env file)
      docker run -p 8080:8080 --env-file .env base-agent

      # Or with docker-compose
      docker-compose up -d

      # Test
      curl http://localhost:8080/health
      curl -X POST http://localhost:8080/execute \
        -H "Content-Type: application/json" \
        -d '{"instruction": "Say hello"}'

tests:
  http:
    - name: health_check
      test: |
        response = http.get("/health")
        assert response.status == 200
        assert response.json()["status"] == "ok"

    - name: execute_simple
      test: |
        response = http.post("/execute", json={
          "instruction": "What is 2 + 2?"
        })
        assert response.status == 200
        assert response.json()["success"] == True

    - name: execute_missing_instruction
      test: |
        response = http.post("/execute", json={})
        assert response.status == 400
        assert "instruction" in response.json()["error"]

    - name: list_tasks
      test: |
        # Create some tasks first
        http.post("/execute", json={"instruction": "Task 1"})
        http.post("/execute", json={"instruction": "Task 2"})

        response = http.get("/tasks?limit=5")
        assert response.status == 200
        assert len(response.json()["tasks"]) >= 2

  docker:
    - name: container_starts
      test: |
        # docker-compose up -d
        # wait for health check
        # curl http://localhost:8080/health
        pass

    - name: env_vars_loaded
      test: |
        # Verify GEMINI_API_KEY is set inside container
        pass
