# Tools Implementation Spec

_meta:
  version: "0.1.0"
  type: spec

implementation:
  registry:
    pseudocode: |
      class ToolRegistry:
        def __init__(self):
          self._tools: dict[str, ToolEntry] = {}

        def register(self, name: str, handler: callable, schema: ToolSchema):
          if name in self._tools:
            raise ValueError(f"Tool {name} already registered")

          # Enforce schema.name consistency
          if not schema.name:
            schema.name = name
          elif schema.name != name:
            raise ValueError(f"Tool schema name mismatch: {schema.name} != {name}")

          self._tools[name] = ToolEntry(
            name=name,
            handler=handler,
            schema=schema
          )

        def execute(self, name: str, args: dict) -> ToolResult:
          if name not in self._tools:
            return ToolResult(
              success=False,
              output=None,
              error=f"Tool {name} not found"
            )

          tool = self._tools[name]

          try:
            output = tool.handler(**args)
            return ToolResult(success=True, output=output, error=None)
          except Exception as e:
            return ToolResult(success=False, output=None, error=str(e))

        def get_schemas(self) -> list[ToolSchema]:
          return [t.schema for t in self._tools.values()]

        def has(self, name: str) -> bool:
          return name in self._tools

        def count(self) -> int:
          return len(self._tools)

        def list_names(self) -> list[str]:
          return list(self._tools.keys())

  types:
    pseudocode: |
      @dataclass
      class ToolSchema:
        name: str
        description: str
        parameters: dict = None  # JSON Schema format

        def to_dict(self) -> dict:
          return {
            "name": self.name,
            "description": self.description,
            "parameters": self.parameters or {"type": "object", "properties": {}}
          }

      @dataclass
      class ToolResult:
        success: bool
        output: any
        error: str = None

      @dataclass
      class ToolEntry:
        name: str
        handler: callable
        schema: ToolSchema

  helpers:
    schema_builder:
      pseudocode: |
        def build_schema(name: str, description: str, **params) -> ToolSchema:
          """Helper to build tool schema"""
          properties = {}
          required = []

          for param_name, param_def in params.items():
            properties[param_name] = {
              "type": param_def.get("type", "string"),
              "description": param_def.get("description", "")
            }
            if param_def.get("required", False):
              required.append(param_name)

          return ToolSchema(
            name=name,
            description=description,
            parameters={
              "type": "object",
              "properties": properties,
              "required": required
            }
          )

        # Usage:
        schema = build_schema(
          "read_file",
          "Read contents of a file",
          path={"type": "string", "description": "File path", "required": True}
        )

tests:
  unit:
    - name: register_and_execute
      test: |
        registry = ToolRegistry()

        def add(a: int, b: int) -> int:
          return a + b

        schema = ToolSchema(
          name="add",
          description="Add two numbers",
          parameters={
            "type": "object",
            "properties": {
              "a": {"type": "integer"},
              "b": {"type": "integer"}
            },
            "required": ["a", "b"]
          }
        )

        registry.register("add", add, schema)
        result = registry.execute("add", {"a": 2, "b": 3})

        assert result.success == True
        assert result.output == 5

    - name: execute_not_found
      test: |
        registry = ToolRegistry()
        result = registry.execute("nonexistent", {})

        assert result.success == False
        assert "not found" in result.error

    - name: execute_with_error
      test: |
        registry = ToolRegistry()

        def failing_tool():
          raise ValueError("Something went wrong")

        registry.register("fail", failing_tool, ToolSchema("fail", "Fails"))
        result = registry.execute("fail", {})

        assert result.success == False
        assert "Something went wrong" in result.error

    - name: get_schemas
      test: |
        registry = ToolRegistry()
        registry.register("a", lambda: 1, ToolSchema("a", "Tool A"))
        registry.register("b", lambda: 2, ToolSchema("b", "Tool B"))

        schemas = registry.get_schemas()
        assert len(schemas) == 2
        names = [s.name for s in schemas]
        assert "a" in names
        assert "b" in names
