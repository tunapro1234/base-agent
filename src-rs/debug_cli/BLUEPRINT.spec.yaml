# Debug CLI Implementation Spec (Rust)

_meta:
  version: "0.2.0"
  type: spec

implementation:
  structure:
    - src/main.rs
    - src/cli.rs
    - src/client.rs
    - src/models.rs
    - src/repl.rs
    - src/render.rs

  models:
    pseudocode: |
      use serde_json::Value;

      pub struct CLIConfig {
          pub base_url: String,
          pub provider: String,
          pub model: Option<String>,
          pub system_prompt: Option<String>,
          pub temperature: f64,
          pub debug: bool,
      }

      pub struct ChatMessage {
          pub role: String,
          pub content: String,
      }

      pub struct ExecuteRequest {
          pub instruction: String,
          pub system_prompt: Option<String>,
          pub provider: Option<String>,
          pub model: Option<String>,
          pub temperature: Option<f64>,
          pub debug: bool,
      }

      pub struct ExecuteResponse {
          pub success: bool,
          pub output: String,
          pub task_id: Option<String>,
          pub trace: Option<Value>,
          pub error: Option<String>,
      }

      pub struct TaskInfo {
          pub id: String,
          pub status: String,
          pub instruction: String,
          pub output: Option<String>,
          pub created_at: String,
      }

  client:
    pseudocode: |
      pub struct HTTPClient {
          pub base_url: String,
          pub token: Option<String>,
      }

      impl HTTPClient {
          pub fn execute(&self, req: ExecuteRequest) -> Result<ExecuteResponse, String> {
              // POST /execute
          }

          pub fn list_tasks(&self, limit: usize) -> Result<Vec<TaskInfo>, String> {
              // GET /tasks?limit=...
          }
      }

  repl:
    pseudocode: |
      pub struct REPL {
          pub config: CLIConfig,
          pub client: HTTPClient,
          pub history: Vec<ChatMessage>,
      }

      impl REPL {
          pub fn run(&mut self) {
              // loop: read input, handle slash commands, call API
          }
      }

  entrypoint:
    pseudocode: |
      fn main() {
          // parse flags, build config, start REPL
      }
