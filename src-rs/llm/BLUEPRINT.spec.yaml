# LLM Client Implementation Spec (Rust)

_meta:
  version: "0.4.0"
  type: spec

implementation:
  structure:
    - lib.rs
    - types.rs
    - router.rs
    - rotation.rs
    - gemini_adapter.rs
    - codex_adapter.rs
    - opus_adapter.rs

  types:
    pseudocode: |
      use serde_json::Value;

      pub struct Message {
          pub role: String,
          pub content: String,
      }

      pub struct ToolCall {
          pub name: String,
          pub args: Value,
      }

      pub struct LLMResponse {
          pub content: String,
          pub tool_calls: Vec<ToolCall>,
          pub raw: Option<Value>,
      }

      pub struct CompletionRequest {
          pub messages: Vec<Message>,
          pub tools: Option<Vec<tools::ToolSchema>>,
          pub temperature: Option<f64>,
          pub model: Option<String>,
          pub provider: Option<String>,
          pub metadata: Option<Value>,
      }

      pub struct ProviderError {
          pub code: String,
          pub message: String,
          pub retryable: bool,
      }

      pub trait ProviderAdapter: Send + Sync {
          fn complete(&self, request: CompletionRequest) -> Result<LLMResponse, ProviderError>;
      }

  router:
    pseudocode: |
      use std::collections::HashMap;
      use std::sync::Arc;

      pub struct LLMRouter {
          default_provider: String,
          providers: HashMap<String, Arc<dyn ProviderAdapter>>,
      }

      impl LLMRouter {
          pub fn new(default_provider: &str) -> Self {
              Self { default_provider: default_provider.to_string(), providers: HashMap::new() }
          }

          pub fn register_provider(&mut self, name: &str, adapter: Arc<dyn ProviderAdapter>) {
              self.providers.insert(name.to_string(), adapter);
          }

          pub fn complete(&self, request: CompletionRequest) -> Result<LLMResponse, ProviderError> {
              let provider = request.provider.clone().unwrap_or_else(|| self.default_provider.clone());
              let adapter = self.providers.get(&provider).ok_or_else(|| ProviderError { code: "provider_missing".to_string(), message: provider, retryable: false })?;
              adapter.complete(request)
          }
      }

  rotation:
    pseudocode: |
      use std::sync::Mutex;

      pub struct Rotator {
          keys: Vec<String>,
          next: Mutex<usize>,
      }

      impl Rotator {
          pub fn new(keys: Vec<String>) -> Self {
              Self { keys, next: Mutex::new(0) }
          }

          pub fn next(&self) -> Option<String> {
              let mut idx = self.next.lock().ok()?;
              if self.keys.is_empty() {
                  return None;
              }
              let key = self.keys[*idx % self.keys.len()].clone();
              *idx += 1;
              Some(key)
          }
      }

  gemini:
    pseudocode: |
      pub struct GeminiConfig {
          pub api_keys: Vec<String>,
          pub base_url: String,
          pub model: String,
          pub temperature: f64,
      }

      pub struct GeminiAdapter {
          cfg: GeminiConfig,
          rotator: Rotator,
      }

      impl GeminiAdapter {
          pub fn new(cfg: GeminiConfig) -> Self {
              Self { rotator: Rotator::new(cfg.api_keys.clone()), cfg }
          }
      }

      impl ProviderAdapter for GeminiAdapter {
          fn complete(&self, request: CompletionRequest) -> Result<LLMResponse, ProviderError> {
              // REST: POST {base_url}/v1beta/models/{model}:generateContent
              // auth: x-goog-api-key header (API key)
              Ok(LLMResponse { content: String::new(), tool_calls: vec![], raw: None })
          }
      }

  codex:
    pseudocode: |
      pub struct CodexConfig {
          pub api_keys: Vec<String>,
          pub auth_files: Vec<String>,
          pub model: String,
          pub reasoning_effort: Option<String>,
      }

      pub struct CodexAdapter {
          cfg: CodexConfig,
          rotator: Rotator,
      }

      impl ProviderAdapter for CodexAdapter {
          fn complete(&self, request: CompletionRequest) -> Result<LLMResponse, ProviderError> {
              // HTTP call to Codex API
              Ok(LLMResponse { content: String::new(), tool_calls: vec![], raw: None })
          }
      }

  opus:
    pseudocode: |
      pub struct OpusConfig {
          pub api_keys: Vec<String>,
          pub base_url: String,
          pub endpoint: String,
          pub model: String,
          pub temperature: f64,
      }

      pub struct OpusAdapter {
          cfg: OpusConfig,
          rotator: Rotator,
      }

      impl ProviderAdapter for OpusAdapter {
          fn complete(&self, request: CompletionRequest) -> Result<LLMResponse, ProviderError> {
              // HTTP call to Opus-compatible endpoint
              Ok(LLMResponse { content: String::new(), tool_calls: vec![], raw: None })
          }
      }

  providers:
    notes: |
      Provider adapter'lar:
      - request/response mapping'i yapar
      - model allowlist uygular
      - rotation manager ile key/account donusumunu yapar
      - tek paket altinda tutulur (subpackage yok)
      - Gemini adapter REST kullanir:
        - base_url: https://generativelanguage.googleapis.com
        - POST /v1beta/models/{model}:generateContent
        - POST /v1beta/models/{model}:streamGenerateContent
        - GET /v1beta/models
        - auth: x-goog-api-key header (API key)

tests:
  unit:
    - name: router_requires_provider
      test: |
        let router = LLMRouter::new("gemini");
        // expect error when provider missing
